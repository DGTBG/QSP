# 登录拦截

## 前端路由简单拦截

```js
router.beforeEach((to, from, next) => {
    if (to.meta.requireAuth) {  // 判断该路由是否需要登录权限
        if (window.localStorage.getItem('token')) {  //获取当前的token
            next();
        }
        else {//token不存在
            next({
                path: '/login',
                query: {redirect: to.fullPath}  // 将跳转的路由path作为参数，登录成功后跳转到该路由
            })
        }
    }
    else {
        next();
    }
})
```

+ to: Route: 即将要进入的目标 路由对象

+ from: Route: 当前导航正要离开的路由

+ next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。

  +  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。
  + next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。
  +  next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。
  + query传参，给跳转的目标页面传递参数

+ 这种方式只是简单的前端路由控制，并不能真正阻止用户访问需要登录权限的路由。还有一种情况便是：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。

  这时候就需要结合 http 拦截器 + 后端接口返回的结果来判断。

## 使用axios拦截器

#### 1.请求拦截器，在发送post请求之前，访问本地存储是否含有token，如果有就加入到data中一起发送给后台

```js
axios.interceptors.request.use((config) => {
    if(config.method  === 'post'){
//获取token
        let token=localStorage.getItem('token');
        if(token){
          config.data=config.data||{};
          config.data.token=token;
        }
 //qs.stringify()将对象序列化成URL的形式，以&进行拼接
        config.data = qs.stringify(config.data);
    }
    return config;
},(error) =>{
    return Promise.reject(error);
});
```

#### 2.在后端，使用router.use中间件对发过来的请求进行处理

```js
router.use(function(req, res, next) {
    req.session.secret=config.dev.secret;
    if(req.url!='/login'&&req.url!='/register'){//判断需要登录验证的路由
      var token = req.body.token || req.query.token || req.headers['x-access-token'];
      if (token) {
          //对token进行验证
        jwt.verify(token, req.session.secret, function (err, decoded) {
          if (err) {
             //token过期，或者不是本人的token
            return res.json({code:'03', result: 'Failed to authenticate token.'})
          } else {
            next();
          }
        })
      } else {
        return res.json({code:'03', result: 'No token provided.'})
      }
    }else{
      // 输出记录信息
      console.log(req.method, req.url);
      // 继续路由处理
      next();
    }
});
```

#### 3.在后台的登录函数中生成token,设置token的时限，以达到控制登录时限的目的

```js
var token = jwt.sign({name:user.name}, req.session.secret, {expiresIn: 60*60*24})
body.token=token;//在req回复中加上token一起返回给前台
```

+ jwt.sign(payload, secretOrPrivateKey, [options, callback])
  + payload：必须是一个object, buffer或者string
  + secretOrPrivateKey：私钥，在config的index.js中进行设置，本项目设置为qsp
  + expiresIn：以秒表示或描述时间跨度zeit / ms的字符串。如：60，"2days"，"10h"，"7d"，本项目设置为一天

#### 4.返回状态拦截器

```js
axios.interceptors.response.use((res) =>{
    if(res.status!==200){
        return Promise.reject(res);
    }
    if(res.data.code=='03'){  //无token或者token认证不正确，重定向到登录页面
      window.location='http://localhost:8080/login?no_token=1';
      return;
    }
    return res;
}, (error) => {
    return Promise.reject(error);
});
```